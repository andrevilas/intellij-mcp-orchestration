"""LangGraph-style stub that wires a single tool node declared in the manifest."""

from __future__ import annotations

from pathlib import Path
from typing import Any, Mapping

from app.schemas.manifest import AgentManifest
from app.schemas.manifest import load_manifest as _load_manifest

from ..orchestration import ExecutionState, GraphBackedAgent


class $agent_class(GraphBackedAgent):
    """Deterministic scaffold ready to be customised with business logic."""

    def __init__(self, manifest: AgentManifest | Mapping[str, Any]) -> None:
        if not isinstance(manifest, AgentManifest):
            manifest = AgentManifest.model_validate(manifest)
        super().__init__(manifest)
        self._hitl_checkpoints = tuple(self.manifest.hitl.checkpoints) if self.manifest.hitl else ()

    def _execute_tool(self, state: ExecutionState) -> Mapping[str, Any]:
        payload = dict(state.payload)
        topic = str(payload.get("topic") or "").strip()
        context = str(payload.get("context") or "").strip()

        if not topic:
            return {
                "status": "error",
                "reason": "Campo 'topic' obrigatório para a ferramenta '$tool_name'.",
            }

        summary = "TODO: substitua este stub por lógica específica do agente."
        if context:
            summary = f"{summary} Contexto: {context}."

        result = {
            "status": "ok",
            "topic": topic,
            "context": context,
            "summary": summary,
        }
        if self._hitl_checkpoints:
            result["pending_checkpoints"] = [checkpoint.name for checkpoint in self._hitl_checkpoints]
        return result

    def _post_process(self, state: ExecutionState) -> Mapping[str, Any]:
        processed = dict(state.result)
        if self._hitl_checkpoints and "hitl_checkpoints" not in processed:
            processed["hitl_checkpoints"] = [
                {
                    "name": checkpoint.name,
                    "description": checkpoint.description,
                    "required": checkpoint.required,
                    "escalation_channel": getattr(checkpoint, "escalation_channel", None),
                }
                for checkpoint in self._hitl_checkpoints
            ]
        return processed

    def _hitl_blocked_payload(self, checkpoint: Any) -> Mapping[str, Any]:
        metadata = {
            "name": getattr(checkpoint, "name", str(checkpoint)),
            "description": getattr(checkpoint, "description", None),
            "required": bool(getattr(checkpoint, "required", False)),
            "escalation_channel": getattr(checkpoint, "escalation_channel", None),
        }
        filtered = {
            key: value
            for key, value in metadata.items()
            if key == "name" or value not in (None, "")
        }
        return {
            "status": "hitl_blocked",
            "checkpoint": filtered["name"],
            "metadata": filtered,
        }


def build_agent(manifest: Mapping[str, Any]) -> $agent_class:
    """Factory used by the registry to construct the agent instance."""

    return $agent_class(manifest=manifest)


def get_tools() -> list[Any]:
    """Expose tool metadata derived from the manifest for discovery APIs."""

    manifest = _load_manifest(Path(__file__).resolve().parent)
    return [tool.model_dump(mode="json") for tool in manifest.tools]


__all__ = ["$agent_class", "build_agent", "get_tools"]
